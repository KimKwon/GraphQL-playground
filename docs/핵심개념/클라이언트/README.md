# 클라이언트

프론트엔드와 GraphQL의 결합은 새로운 추상화를 제공함은 물론 클라이언트 사이드의 공통 기능을 구현하는 데 도움을 줄 수 있는 좋은 기회이다.

우리가 애플리케이션에서 필요로 하는 "infrastructure"를 고려해보자.

* HTTP 요청 구조화 없이 쿼리와 뮤테이션을 보내는 것.
* view - layer 통합
* 캐싱
* 스키마를 기반으로 한 validation과 쿼리의 최적화

물론 plain HTTP를 사용해 데이터를 패치하는 방식을 쓰는 것을 막지 않는다.
다만 GraphQL은 위 과정에서 정형화된 작업을 너가 하지 않을 수 있도록 갖다 치워버렸다.
또한 그 정형화된 작업을 하는 시간에 너의 앱에 좀 더 중요한 부분에 시간을 쏟도록 도와준다.

> GraphQL 클라이언트는 현재 크게 두가지로 나뉜다.
> 1. Apollo Client
> 2. Relay
> 1의 경우 커뮤니티 기반으로 강력하고 유연한 클라이언트를 구성하기 위한 대규모 개발 플랫폼이다.
> 2의 경우 페이스북 자체 GraphQL 클라이언트이고 성능 최적화가 야무지고 웹에서만 이용 가능하다.

## 직접 쿼리와 뮤테이션을 보낸다.

GraphQL이 주는 장점 중 하나는 데이터를 fetch & update 를 선언적인 방식으로 할 수 있게 해주는 것이다.

plain HTTP 방식을 사용하여 데이터를 불러왔던 이전의 방식과 비교해보면
GraphQL에서 니가 필요한 건 요구하는 데이터가 명시되어 있으며 요청과 응답을 핸들링할 수 있도록 설계된 쿼리 하나 뿐이다.

이게 GraphQL 클라이언트가 하게 될 명확한 업무이다.

## View Layer 통합과 UI 업데이트

GraphQL client에 의해 서버응답이 수신되고 처리되면 요청된 데이터는 결국 어떻게든 UI 상에 나타내는데 필요할 것이다.
너가 개발하고 있는 프레임워크와 플랫폼에 따라 UI를 어떻게 업데이트하고 핸들링하는지는 접근 방식이 다를 것이다.

리액트를 예로 들어서 GraphQL clients는 고차 컴포넌트 개념을 사용해서 기저 데이터를 패치하고 너의 컴포넌트의 props 안에서 이용가능하도록 해준다.

일반적으로 GraphQL의 선언적 특징은 함수형 프로그래밍 기법과 잘 연결된다.

뷰가 데이터 의존성을 나타낼 수 있으며 UI가 FRP 레이어와 연결되어 있다는 점에서 강력한 조화를 이룬다.

## 쿼리 결과 캐싱 : 개념과 전략

대다수의 애플리케이션에서는 서버로부터 이전의 받은 값을 캐싱하고 싶을 것이다.
로컬에서 정보를 캐싱하는 것은 유연한 UX를 제공하는 것과 유저의 데이터 관련 고민을 덜어주는데 필수적이다.

일반적으로 데이터를 캐싱할 때는 나중에 다시 쓰일 수 있기에 로컬 저장소에 정보를 넣어놓는 것을 말한다.
GraphQL에서는 단순한 접근은 쿼리의 결과를 단순히 저장소에 박아둔 뒤 같은 쿼리 요청이 오면 이를 보내주는 것인데 대다수의 애플리케이션에서 비효율적인 것으로 드러났다.

더 효율적인 방식은 데이터를 미리 정규화하는 것이다.

뭔 말이냐면, 쿼리 결과가 flattened되고 저장소에는 전역적으로 유니크한 ID를 통해 접근 가능한 individual record만 포함한다는 것이다.

더 배우고 싶으면 [아폴로 블로그](https://dev-blog.apollodata.com/the-concepts-of-graphql-bc68bd819be3)를 가봐라 . .. 

## 빌드 타임 스키마 validation & optimizations

스키마는 GraphQL API를 통해 잠재적으로 할 수 있는 모든 일에 대한 정보를 포함하고 있기 때문에 
클라이언트가 원하는 정보에 대한 쿼리를 validate하고 optimize하는 작업이 빌드타임에 할 수 있는 기회가 있다.

빌드 환경에서 스키마에 접근 가능할 때, 프로젝트에 있는 모든 GraphQL 코드를 파싱하고 스키마에 있는 정보와 비교한다. 

실제 유저가 앱을 사용하기 이전에 오타나 에러를 미리 검출할 수 있게 된다. 

## Colocating Views and Data Dependencies

GraphQL의 강력한 개념은 UI 코드와 데이터 요구사항을 side-by-side로 가질 수 있게 하는 것이다.

뷰와 데이터의 의존성이 갖는 결합도는 개발자의 경험을 엄청 향상시켜준다.
UI와 데이터에서 어떻게 해야 잘 끝나고 ... 뭐 이런 고민하는 것을 머리속에서 지워준다.

JS 애플리케이션을 예로 들었을 때 데이터 의존성과 UI 관련 코드를 하나의 파일에 집어 넣는게 가능하다.

> GraphQL 공식문서를 번역함.
> https://www.howtographql.com/advanced/0-clients/

